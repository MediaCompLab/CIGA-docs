<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Analysis (ciga) &#8212; CIGA 2025 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/documentation_options.js?v=cb975c41"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Visualization (ciga)" href="visualization.html" />
    <link rel="prev" title="Graph (ciga)" href="graph.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="analysis-ciga">
<h1>Analysis (<code class="xref py py-mod docutils literal notranslate"><span class="pre">ciga</span></code>)<a class="headerlink" href="#analysis-ciga" title="Link to this heading">¶</a></h1>
<p>This module provides comprehensive graph analysis functions including centrality measures, community detection, and graph properties for both static and temporal graphs.</p>
<section id="centrality-analysis">
<h2>Centrality Analysis<a class="headerlink" href="#centrality-analysis" title="Link to this heading">¶</a></h2>
<section id="static-graph-centrality">
<h3>Static Graph Centrality<a class="headerlink" href="#static-graph-centrality" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="ciga.graph_degree">
<span class="sig-prename descclassname"><span class="pre">ciga.</span></span><span class="sig-name descname"><span class="pre">graph_degree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="reference internal" href="_modules/ciga/analysis/graph_centrality_analysis.html#graph_degree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ciga.graph_degree" title="Link to this definition">¶</a></dt>
<dd><p>Calculate various degree centrality measures for each vertex in the graph.</p>
<p>This function computes degree-based centrality metrics, including in-degree, out-degree,
total degree, and their weighted counterparts for directed graphs. For undirected graphs,
it calculates the degree and weighted degree centrality. Additionally, it supports
normalization of these centrality measures based on the number of vertices in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>igraph.Graph</em>) – The input graph on which degree centrality measures are to be computed.
Must be an instance of igraph’s <cite>Graph</cite> class.</p></li>
<li><p><strong>weighted</strong> (<em>bool</em><em>, </em><em>optional</em>) – If set to <cite>True</cite>, the function calculates weighted degree centrality
using edge weights. Defaults to <cite>False</cite>.</p></li>
<li><p><strong>normalized</strong> (<em>bool</em><em>, </em><em>optional</em>) – If set to <cite>True</cite>, the degree centrality measures are normalized by
dividing by (n-1), where n is the number of vertices in the graph.
This normalization facilitates comparison across graphs of different sizes.
Defaults to <cite>False</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A pandas DataFrame containing the calculated degree centrality measures.
The columns vary based on whether the graph is directed and whether
weighting and normalization are applied.</p>
<ul class="simple">
<li><dl class="simple">
<dt>For <strong>directed graphs</strong>:</dt><dd><ul>
<li><p><cite>in_degree</cite>: Number of incoming edges per vertex.</p></li>
<li><p><cite>out_degree</cite>: Number of outgoing edges per vertex.</p></li>
<li><p><cite>all_degree</cite>: Total degree (in-degree + out-degree) per vertex.</p></li>
<li><p><cite>weighted_in_degree</cite> <em>(if `weighted=True`)</em>: Sum of weights of incoming edges.</p></li>
<li><p><cite>weighted_out_degree</cite> <em>(if `weighted=True`)</em>: Sum of weights of outgoing edges.</p></li>
<li><p><cite>weighted_all_degree</cite> <em>(if `weighted=True`)</em>: Sum of weights of all edges.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>For <strong>undirected graphs</strong>:</dt><dd><ul>
<li><p><cite>degree</cite>: Number of edges per vertex.</p></li>
<li><p><cite>weighted_degree</cite> <em>(if `weighted=True`)</em>: Sum of weights of edges per vertex.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Normalization</strong> <em>(if `normalized=True`)</em>:</dt><dd><ul>
<li><p>Additional columns prefixed with <cite>normalized_</cite> representing the normalized
centrality measures (e.g., <cite>normalized_degree</cite>, <cite>normalized_in_degree</cite>, etc.).</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – <ul class="simple">
<li><p>If the graph does not contain edge weights but <cite>weighted=True</cite> is specified.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>python
import igraph as ig
import pandas as pd
from ciga.analysis.graph_centrality_analysis import graph_degree</p>
<p># Create a sample directed graph
g = ig.Graph(directed=True)
g.add_vertices(4)
g.vs[‘name’] = [‘A’, ‘B’, ‘C’, ‘D’]
g.add_edges([(‘A’, ‘B’), (‘B’, ‘C’), (‘C’, ‘A’), (‘A’, ‘D’)])
g.es[‘weight’] = [1.5, 2.0, 2.5, 1.0]</p>
<p># Calculate degree centrality
degree_df = graph_degree(g, weighted=True, normalized=True)
print(degree_df)
<a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ciga.graph_betweenness">
<span class="sig-prename descclassname"><span class="pre">ciga.</span></span><span class="sig-name descname"><span class="pre">graph_betweenness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="reference internal" href="_modules/ciga/analysis/graph_centrality_analysis.html#graph_betweenness"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ciga.graph_betweenness" title="Link to this definition">¶</a></dt>
<dd><p>Compute betweenness centrality for each vertex in the graph.</p>
<p>This function calculates the betweenness centrality, which measures the extent to
which a vertex lies on paths between other vertices. It supports both weighted and
unweighted graphs and allows for normalization of the centrality scores. Additional
parameters enable customization of the computation, such as limiting the analysis to
specific sources, targets, or path lengths.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>igraph.Graph</em>) – The input graph on which betweenness centrality is to be computed.
Must be an instance of igraph’s <cite>Graph</cite> class.</p></li>
<li><p><strong>weighted</strong> (<em>bool</em><em>, </em><em>optional</em>) – If set to <cite>True</cite>, the function calculates weighted betweenness centrality
using edge weights. Defaults to <cite>False</cite>.</p></li>
<li><p><strong>cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Specifies the maximum path length to consider when calculating betweenness.
Paths longer than the cutoff are ignored. Defaults to <cite>None</cite>, which considers
all possible paths.</p></li>
<li><p><strong>sources</strong> (<em>list</em><em>, </em><em>optional</em>) – A list of vertex indices to be used as sources for the betweenness calculation.
If specified, only paths originating from these sources are considered. Defaults to <cite>None</cite>,
which includes all vertices as potential sources.</p></li>
<li><p><strong>targets</strong> (<em>list</em><em>, </em><em>optional</em>) – A list of vertex indices to be used as targets for the betweenness calculation.
If specified, only paths ending at these targets are considered. Defaults to <cite>None</cite>,
which includes all vertices as potential targets.</p></li>
<li><p><strong>normalized</strong> (<em>bool</em><em>, </em><em>optional</em>) – If set to <cite>True</cite>, the betweenness centrality scores are normalized by dividing by
the number of possible pairs of vertices not including the vertex itself. This makes
the centrality scores comparable across graphs of different sizes. Defaults to <cite>False</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A pandas DataFrame containing the calculated betweenness centrality measures.
The DataFrame includes the following columns based on the input parameters:</p>
<ul class="simple">
<li><p><cite>betweenness</cite>: Unweighted betweenness centrality.</p></li>
<li><p><cite>weighted_betweenness</cite> <em>(if `weighted=True`)</em>: Weighted betweenness centrality.</p></li>
</ul>
<p>If <cite>normalized=True</cite>, additional columns with normalized scores are included:
- <cite>normalized_betweenness</cite>
- <cite>normalized_weighted_betweenness</cite> <em>(if `weighted=True`)</em></p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – <ul class="simple">
<li><p>If the graph does not contain edge weights but <cite>weighted=True</cite> is specified.
    - If <cite>sources</cite> or <cite>targets</cite> contain invalid vertex indices.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p><a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">`</span></a>python
import igraph as ig
import pandas as pd
from ciga.analysis.graph_centrality_analysis import graph_betweenness</p>
<p># Create a sample undirected graph
g = ig.Graph(edges=[(0, 1), (1, 2), (2, 3), (3, 0), (1, 3)])
g.vs[‘name’] = [‘A’, ‘B’, ‘C’, ‘D’]
g.es[‘weight’] = [1, 2, 1, 3, 2]</p>
<p># Calculate betweenness centrality
betweenness_df = graph_betweenness(g, weighted=True, normalized=True)
print(betweenness_df)
<a href="#id13"><span class="problematic" id="id14">``</span></a><a href="#id15"><span class="problematic" id="id16">`</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ciga.graph_closeness">
<span class="sig-prename descclassname"><span class="pre">ciga.</span></span><span class="sig-name descname"><span class="pre">graph_closeness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="reference internal" href="_modules/ciga/analysis/graph_centrality_analysis.html#graph_closeness"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ciga.graph_closeness" title="Link to this definition">¶</a></dt>
<dd><p>Calculate closeness centrality measures for each vertex in the graph.</p>
<p>Closeness centrality assesses how close a vertex is to all other vertices in the graph.
It is defined as the reciprocal of the sum of the shortest path distances from the vertex
to all other vertices. This function supports both weighted and unweighted graphs and
allows for normalization of the closeness scores. Additionally, it offers the ability to
limit the analysis to paths within a specified cutoff and to compute centrality for specific
modes (in, out, all) in directed graphs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>igraph.Graph</em>) – The input graph on which closeness centrality is to be computed.
Must be an instance of igraph’s <cite>Graph</cite> class.</p></li>
<li><p><strong>weighted</strong> (<em>bool</em>) – If set to <cite>True</cite>, the function calculates weighted closeness centrality
using edge weights. Must be explicitly provided (no default value).</p></li>
<li><p><strong>cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Specifies the maximum path length to consider when calculating closeness.
Paths longer than the cutoff are ignored. Defaults to <cite>None</cite>, which considers
all possible paths.</p></li>
<li><p><strong>normalized</strong> (<em>bool</em><em>, </em><em>optional</em>) – If set to <cite>True</cite>, the closeness centrality scores are normalized based on
the number of reachable vertices. This makes the centrality scores comparable
across graphs of different sizes and densities. Defaults to <cite>False</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A pandas DataFrame containing the calculated closeness centrality measures.
The columns vary based on whether the graph is directed and whether
weighting and normalization are applied.</p>
<ul class="simple">
<li><dl class="simple">
<dt>For <strong>directed graphs</strong>:</dt><dd><ul>
<li><p><cite>in_closeness</cite>: Closeness centrality based on incoming paths.</p></li>
<li><p><cite>out_closeness</cite>: Closeness centrality based on outgoing paths.</p></li>
<li><p><cite>all_closeness</cite>: Closeness centrality considering all paths.</p></li>
<li><p><cite>weighted_in_closeness</cite> <em>(if `weighted=True`)</em>: Weighted in-closeness centrality.</p></li>
<li><p><cite>weighted_out_closeness</cite> <em>(if `weighted=True`)</em>: Weighted out-closeness centrality.</p></li>
<li><p><cite>weighted_all_closeness</cite> <em>(if `weighted=True`)</em>: Weighted all-closeness centrality.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>For <strong>undirected graphs</strong>:</dt><dd><ul>
<li><p><cite>closeness</cite>: Closeness centrality.</p></li>
<li><p><cite>weighted_closeness</cite> <em>(if `weighted=True`)</em>: Weighted closeness centrality.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Normalization</strong> <em>(if `normalized=True`)</em>:</dt><dd><ul>
<li><p>Additional columns prefixed with <cite>normalized_</cite> representing the normalized
closeness centrality measures (e.g., <cite>normalized_closeness</cite>, <cite>normalized_in_closeness</cite>, etc.).</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – <ul class="simple">
<li><p>If the graph does not contain edge weights but <cite>weighted=True</cite> is specified.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p><a href="#id17"><span class="problematic" id="id18">``</span></a><a href="#id19"><span class="problematic" id="id20">`</span></a>python
import igraph as ig
import pandas as pd
from ciga.analysis.graph_centrality_analysis import graph_closeness</p>
<p># Create a sample directed graph
g = ig.Graph(directed=True)
g.add_vertices(3)
g.vs[‘name’] = [‘A’, ‘B’, ‘C’]
g.add_edges([(‘A’, ‘B’), (‘B’, ‘C’)])
g.es[‘weight’] = [1, 2]</p>
<p># Calculate closeness centrality
closeness_df = graph_closeness(g, weighted=True, normalized=True)
print(closeness_df)
<a href="#id21"><span class="problematic" id="id22">``</span></a><a href="#id23"><span class="problematic" id="id24">`</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ciga.graph_eigenvector_centrality">
<span class="sig-prename descclassname"><span class="pre">ciga.</span></span><span class="sig-name descname"><span class="pre">graph_eigenvector_centrality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_eigenvalue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="reference internal" href="_modules/ciga/analysis/graph_centrality_analysis.html#graph_eigenvector_centrality"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ciga.graph_eigenvector_centrality" title="Link to this definition">¶</a></dt>
<dd><p>Compute eigenvector centrality for each vertex in the graph.</p>
<p>Eigenvector centrality measures a vertex’s influence based on the influence of its neighbors.
It assigns relative scores to all vertices in the network based on the concept that connections
to high-scoring vertices contribute more to the score of the vertex in question than connections
to low-scoring vertices. This function supports both weighted and unweighted graphs, allows
scaling of the centrality scores, and can optionally return the corresponding eigenvalues.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>igraph.Graph</em>) – The input graph on which eigenvector centrality is to be computed.
Must be an instance of igraph’s <cite>Graph</cite> class.</p></li>
<li><p><strong>weighted</strong> (<em>bool</em><em>, </em><em>optional</em>) – If set to <cite>True</cite>, the function calculates eigenvector centrality
using edge weights. Defaults to <cite>False</cite>.</p></li>
<li><p><strong>scale</strong> (<em>bool</em><em>, </em><em>optional</em>) – If set to <cite>True</cite>, the centrality scores are scaled to have a mean of 0 and a
variance of 1. Scaling can be useful for comparative analysis. Defaults to <cite>True</cite>.</p></li>
<li><p><strong>return_eigenvalue</strong> (<em>bool</em><em>, </em><em>optional</em>) – If set to <cite>True</cite>, the function returns the principal eigenvalue associated
with the eigenvector centrality calculation. This can provide insights into
the graph’s connectivity and structure. Defaults to <cite>False</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A pandas DataFrame containing the calculated eigenvector centrality measures.
The columns included in the DataFrame depend on the input parameters.</p>
<ul class="simple">
<li><p><cite>eigenvector_centrality</cite>: The eigenvector centrality score for each vertex.</p></li>
<li><p><cite>eigenvalue</cite> <em>(if `return_eigenvalue=True`)</em>: The principal eigenvalue associated with
the eigenvector centrality computation.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – <ul class="simple">
<li><p>If the graph does not contain edge weights but <cite>weighted=True</cite> is specified.
    - If the graph is not strongly connected, making eigenvector centrality undefined.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p><a href="#id25"><span class="problematic" id="id26">``</span></a><a href="#id27"><span class="problematic" id="id28">`</span></a>python
import igraph as ig
import pandas as pd
from ciga.analysis.graph_centrality_analysis import graph_eigenvector_centrality</p>
<p># Create a sample undirected graph
g = ig.Graph(edges=[(0, 1), (1, 2), (2, 3), (3, 0), (1, 3)])
g.vs[‘name’] = [‘A’, ‘B’, ‘C’, ‘D’]
g.es[‘weight’] = [1, 2, 1, 3, 2]</p>
<p># Calculate eigenvector centrality
eigen_df = graph_eigenvector_centrality(g, weighted=True, scale=True, return_eigenvalue=True)
print(eigen_df)
<a href="#id29"><span class="problematic" id="id30">``</span></a><a href="#id31"><span class="problematic" id="id32">`</span></a></p>
</dd></dl>

</section>
<section id="temporal-graph-centrality">
<h3>Temporal Graph Centrality<a class="headerlink" href="#temporal-graph-centrality" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="ciga.tgraph_degree">
<span class="sig-prename descclassname"><span class="pre">ciga.</span></span><span class="sig-name descname"><span class="pre">tgraph_degree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tgraph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="graph.html#ciga.TGraph" title="ciga.ciga.TGraph"><span class="pre">TGraph</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accumulate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="reference internal" href="_modules/ciga/analysis/tgraph_centrality_analysis.html#tgraph_degree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ciga.tgraph_degree" title="Link to this definition">¶</a></dt>
<dd><p>Perform degree centrality analysis on a time-varying graph.</p>
<p>This function calculates the degree centrality for each vertex across the specified time steps of the
given <cite>TGraph</cite> object. Degree centrality measures the number of direct connections a vertex has.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tgraph</strong> (<a class="reference internal" href="graph.html#ciga.TGraph" title="ciga.TGraph"><em>TGraph</em></a>) – The time-varying graph to analyze.</p></li>
<li><p><strong>start</strong> (<em>optional</em>) – The starting time step for the analysis. Only time steps &gt;= start will be included.
Defaults to <cite>None</cite>.</p></li>
<li><p><strong>end</strong> (<em>optional</em>) – The ending time step for the analysis. Only time steps &lt;= end will be included.
Defaults to <cite>None</cite>.</p></li>
<li><p><strong>accumulate</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, the graph snapshots will accumulate over time, incorporating changes from all
previous steps. If <cite>False</cite>, each snapshot represents only the changes at that time step.
Defaults to <cite>True</cite>.</p></li>
<li><p><strong>weighted</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, computes weighted degree centrality using edge weights. If <cite>False</cite>, computes
unweighted degree centrality. Defaults to <cite>False</cite>.</p></li>
<li><p><strong>w_normalized</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, normalizes the graph weights before computing centrality measures.
Defaults to <cite>False</cite>.</p></li>
<li><p><strong>normalized</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, normalizes the degree centrality by dividing by (n-1), where n is the number of vertices.
This makes centrality scores comparable across graphs of different sizes.
Defaults to <cite>False</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A DataFrame containing the degree centrality measures for each vertex at each time step.
Columns include positional information, character names, and the calculated degree measures.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">degree_centrality</span> <span class="pre">=</span> <span class="pre">tgraph_degree(tg,</span> <span class="pre">weighted=True,</span> <span class="pre">normalized=True)</span>
<span class="pre">print(degree_centrality)</span>
<span class="pre">`</span></code></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ciga.tgraph_betweenness">
<span class="sig-prename descclassname"><span class="pre">ciga.</span></span><span class="sig-name descname"><span class="pre">tgraph_betweenness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tgraph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="graph.html#ciga.TGraph" title="ciga.ciga.TGraph"><span class="pre">TGraph</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accumulate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sources</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">targets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="reference internal" href="_modules/ciga/analysis/tgraph_centrality_analysis.html#tgraph_betweenness"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ciga.tgraph_betweenness" title="Link to this definition">¶</a></dt>
<dd><p>Perform betweenness centrality analysis on a time-varying graph.</p>
<p>This function calculates the betweenness centrality for each vertex across the specified time steps of the
given <cite>TGraph</cite> object. Betweenness centrality measures the extent to which a vertex lies on paths between
other vertices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tgraph</strong> (<a class="reference internal" href="graph.html#ciga.TGraph" title="ciga.TGraph"><em>TGraph</em></a>) – The time-varying graph to analyze.</p></li>
<li><p><strong>start</strong> (<em>optional</em>) – The starting time step for the analysis. Only time steps &gt;= start will be included.
Defaults to <cite>None</cite>.</p></li>
<li><p><strong>end</strong> (<em>optional</em>) – The ending time step for the analysis. Only time steps &lt;= end will be included.
Defaults to <cite>None</cite>.</p></li>
<li><p><strong>accumulate</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, the graph snapshots will accumulate over time, incorporating changes from all
previous steps. If <cite>False</cite>, each snapshot represents only the changes at that time step.
Defaults to <cite>True</cite>.</p></li>
<li><p><strong>weighted</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, computes weighted betweenness centrality using edge weights. If <cite>False</cite>, computes
unweighted betweenness centrality. Defaults to <cite>False</cite>.</p></li>
<li><p><strong>w_normalized</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, normalizes the graph weights before computing centrality measures.
Defaults to <cite>False</cite>.</p></li>
<li><p><strong>normalized</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, normalizes the betweenness centrality scores. This makes centrality scores
comparable across graphs of different sizes. Defaults to <cite>True</cite>.</p></li>
<li><p><strong>cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Specifies the maximum path length to consider when calculating betweenness centrality.
Paths longer than the cutoff are ignored. Defaults to <cite>None</cite>, which considers all paths.</p></li>
<li><p><strong>sources</strong> (<em>list</em><em>, </em><em>optional</em>) – A list of vertex indices to be used as sources for the betweenness calculation.
If specified, only paths originating from these sources are considered. Defaults to <cite>None</cite>,
which includes all vertices as potential sources.</p></li>
<li><p><strong>targets</strong> (<em>list</em><em>, </em><em>optional</em>) – A list of vertex indices to be used as targets for the betweenness calculation.
If specified, only paths ending at these targets are considered. Defaults to <cite>None</cite>,
which includes all vertices as potential targets.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A DataFrame containing the betweenness centrality measures for each vertex at each time step.
Columns include positional information, character names, and the calculated betweenness measures.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">betweenness_centrality</span> <span class="pre">=</span> <span class="pre">tgraph_betweenness(tg,</span> <span class="pre">weighted=True,</span> <span class="pre">normalized=True)</span>
<span class="pre">print(betweenness_centrality)</span>
<span class="pre">`</span></code></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ciga.tgraph_closeness">
<span class="sig-prename descclassname"><span class="pre">ciga.</span></span><span class="sig-name descname"><span class="pre">tgraph_closeness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tgraph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="graph.html#ciga.TGraph" title="ciga.ciga.TGraph"><span class="pre">TGraph</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accumulate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="reference internal" href="_modules/ciga/analysis/tgraph_centrality_analysis.html#tgraph_closeness"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ciga.tgraph_closeness" title="Link to this definition">¶</a></dt>
<dd><p>Perform closeness centrality analysis on a time-varying graph.</p>
<p>This function calculates the closeness centrality for each vertex across the specified time steps of the
given <cite>TGraph</cite> object. Closeness centrality measures how close a vertex is to all other vertices in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tgraph</strong> (<a class="reference internal" href="graph.html#ciga.TGraph" title="ciga.TGraph"><em>TGraph</em></a>) – The time-varying graph to analyze.</p></li>
<li><p><strong>start</strong> (<em>optional</em>) – The starting time step for the analysis. Only time steps &gt;= start will be included.
Defaults to <cite>None</cite>.</p></li>
<li><p><strong>end</strong> (<em>optional</em>) – The ending time step for the analysis. Only time steps &lt;= end will be included.
Defaults to <cite>None</cite>.</p></li>
<li><p><strong>accumulate</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, the graph snapshots will accumulate over time, incorporating changes from all
previous steps. If <cite>False</cite>, each snapshot represents only the changes at that time step.
Defaults to <cite>True</cite>.</p></li>
<li><p><strong>weighted</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, computes weighted closeness centrality using edge weights. If <cite>False</cite>, computes
unweighted closeness centrality. Defaults to <cite>False</cite>.</p></li>
<li><p><strong>w_normalized</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, normalizes the graph weights before computing centrality measures.
Defaults to <cite>False</cite>.</p></li>
<li><p><strong>normalized</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, normalizes the closeness centrality scores. This makes centrality scores
comparable across graphs of different sizes. Defaults to <cite>True</cite>.</p></li>
<li><p><strong>cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Specifies the maximum path length to consider when calculating closeness centrality.
Paths longer than the cutoff are ignored. Defaults to <cite>None</cite>, which considers all paths.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A DataFrame containing the closeness centrality measures for each vertex at each time step.
Columns include positional information, character names, and the calculated closeness measures.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">closeness_centrality</span> <span class="pre">=</span> <span class="pre">tgraph_closeness(tg,</span> <span class="pre">weighted=True,</span> <span class="pre">normalized=True)</span>
<span class="pre">print(closeness_centrality)</span>
<span class="pre">`</span></code></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ciga.tgraph_eigenvector_centrality">
<span class="sig-prename descclassname"><span class="pre">ciga.</span></span><span class="sig-name descname"><span class="pre">tgraph_eigenvector_centrality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tgraph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="graph.html#ciga.TGraph" title="ciga.ciga.TGraph"><span class="pre">TGraph</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accumulate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_eigenvalue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="reference internal" href="_modules/ciga/analysis/tgraph_centrality_analysis.html#tgraph_eigenvector_centrality"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ciga.tgraph_eigenvector_centrality" title="Link to this definition">¶</a></dt>
<dd><p>Perform eigenvector centrality analysis on a time-varying graph.</p>
<p>This function calculates the eigenvector centrality for each vertex across the specified time steps of the
given <cite>TGraph</cite> object. Eigenvector centrality measures a vertex’s influence based on the influence of its neighbors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tgraph</strong> (<a class="reference internal" href="graph.html#ciga.TGraph" title="ciga.TGraph"><em>TGraph</em></a>) – The time-varying graph to analyze.</p></li>
<li><p><strong>start</strong> (<em>optional</em>) – The starting time step for the analysis. Only time steps &gt;= start will be included.
Defaults to <cite>None</cite>.</p></li>
<li><p><strong>end</strong> (<em>optional</em>) – The ending time step for the analysis. Only time steps &lt;= end will be included.
Defaults to <cite>None</cite>.</p></li>
<li><p><strong>accumulate</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, the graph snapshots will accumulate over time, incorporating changes from all
previous steps. If <cite>False</cite>, each snapshot represents only the changes at that time step.
Defaults to <cite>True</cite>.</p></li>
<li><p><strong>weighted</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, computes weighted eigenvector centrality using edge weights. If <cite>False</cite>, computes
unweighted eigenvector centrality. Defaults to <cite>False</cite>.</p></li>
<li><p><strong>scale</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, scales the eigenvector centrality scores to have a mean of 0 and a variance of 1.
Defaults to <cite>True</cite>.</p></li>
<li><p><strong>return_eigenvalue</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, returns the principal eigenvalue associated with the eigenvector centrality calculation.
Defaults to <cite>False</cite>.</p></li>
<li><p><strong>options</strong> (<em>dict</em><em>, </em><em>optional</em>) – Additional options to customize the eigenvector centrality computation. These will be passed
directly to the underlying centrality computation function. Defaults to <cite>None</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A DataFrame containing the eigenvector centrality measures for each vertex at each time step.
Columns include positional information, character names, and the calculated centrality measures.
If <cite>return_eigenvalue=True</cite>, additional columns for eigenvalues are included.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">eigen_centrality</span> <span class="pre">=</span> <span class="pre">tgraph_eigenvector_centrality(tg,</span> <span class="pre">weighted=True,</span> <span class="pre">scale=True,</span> <span class="pre">return_eigenvalue=True)</span>
<span class="pre">print(eigen_centrality)</span>
<span class="pre">`</span></code></p>
</dd></dl>

</section>
</section>
<section id="community-detection">
<h2>Community Detection<a class="headerlink" href="#community-detection" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="ciga.graph_community_leiden">
<span class="sig-prename descclassname"><span class="pre">ciga.</span></span><span class="sig-name descname"><span class="pre">graph_community_leiden</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'weight'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">objective_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'CPM'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_membership</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="reference internal" href="_modules/ciga/analysis/graph_community_analysis.html#graph_community_leiden"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ciga.graph_community_leiden" title="Link to this definition">¶</a></dt>
<dd><p>Detect communities in a graph using the Leiden algorithm.</p>
<p>The Leiden algorithm is a method for detecting communities in large networks. It optimizes
the partitioning of the graph to maximize the quality function (e.g., CPM - Constant Potts Model).
This function supports both weighted and unweighted graphs and allows for various customizations
through its parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>igraph.Graph</em>) – The input graph on which community detection is to be performed.
Must be an instance of igraph’s <cite>Graph</cite> class.</p></li>
<li><p><strong>weights</strong> (<em>str</em><em> or </em><em>list</em><em>, </em><em>optional</em>) – The edge attribute used as weights for the community detection algorithm.
If set to <cite>None</cite>, the graph is treated as unweighted. Defaults to <cite>‘weight’</cite>.</p></li>
<li><p><strong>objective_function</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>The objective function to optimize during community detection.
Common options include:</p>
<blockquote>
<div><ul>
<li><p><cite>’CPM’</cite>: Constant Potts Model</p></li>
<li><p><cite>’Modularity’</cite></p></li>
<li><p><cite>’Negative Log-likelihood’</cite></p></li>
</ul>
</div></blockquote>
<p>Defaults to <cite>‘CPM’</cite>.</p>
</p></li>
<li><p><strong>resolution</strong> (<em>float</em><em>, </em><em>optional</em>) – The resolution parameter that influences the size of the communities detected.
Higher values lead to detecting smaller communities. Only applicable for certain
objective functions like CPM. Defaults to <cite>1.0</cite>.</p></li>
<li><p><strong>beta</strong> (<em>float</em><em>, </em><em>optional</em>) – The resolution limit parameter. It influences the balance between the
quality of the partitioning and computational efficiency. Defaults to <cite>0.01</cite>.</p></li>
<li><p><strong>initial_membership</strong> (<em>list</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – A list specifying the initial community membership of each vertex.
If <cite>None</cite>, the algorithm starts with a random partition. Useful for initializing
the algorithm with a known partition. Defaults to <cite>None</cite>.</p></li>
<li><p><strong>n_iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of iterations the Leiden algorithm should perform.
More iterations can lead to more refined community structures but increase computation time.
Defaults to <cite>2</cite>.</p></li>
<li><p><strong>node_weights</strong> (<em>list</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – A list of weights for each node, influencing the community detection.
If <cite>None</cite>, all nodes are treated with equal weight. Useful for emphasizing certain nodes.
Defaults to <cite>None</cite>.</p></li>
<li><p><strong>**kwds</strong> – Additional keyword arguments passed to the underlying Leiden implementation.
Allows for further customization and fine-tuning of the algorithm.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A pandas DataFrame containing the community assignments for each vertex in the graph.
The DataFrame includes the following columns:</p>
<ul class="simple">
<li><p><cite>character</cite>: The name or identifier of the vertex.</p></li>
<li><p><cite>community</cite>: The community index to which the vertex belongs.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – <ul class="simple">
<li><p>If the specified <cite>weights</cite> attribute does not exist in the graph’s edge attributes.
    - If <cite>initial_membership</cite> length does not match the number of vertices in the graph.
    - If invalid parameters are provided to the Leiden algorithm.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p><a href="#id33"><span class="problematic" id="id34">``</span></a><a href="#id35"><span class="problematic" id="id36">`</span></a>python:ciga/analysis/graph_community_analysis.py
import igraph as ig
import pandas as pd
from ciga.analysis.graph_community_analysis import graph_community_leiden</p>
<p># Create a sample undirected graph
g = ig.Graph(edges=[(0, 1), (1, 2), (2, 3), (3, 0), (1, 3)])
g.vs[‘name’] = [‘A’, ‘B’, ‘C’, ‘D’]
g.es[‘weight’] = [1, 2, 1, 3]</p>
<p># Perform community detection using the Leiden algorithm
communities_df = graph_community_leiden(</p>
<blockquote>
<div><p>graph=g,
weights=’weight’,
objective_function=’CPM’,
resolution=1.0,
beta=0.01,
n_iterations=3</p>
</div></blockquote>
<p>)</p>
<p>print(communities_df)
<a href="#id37"><span class="problematic" id="id38">``</span></a><a href="#id39"><span class="problematic" id="id40">`</span></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ciga.tgraph_community_leiden">
<span class="sig-prename descclassname"><span class="pre">ciga.</span></span><span class="sig-name descname"><span class="pre">tgraph_community_leiden</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tgraph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="graph.html#ciga.TGraph" title="ciga.ciga.TGraph"><span class="pre">TGraph</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accumulate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'weight'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">objective_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'CPM'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_membership</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="reference internal" href="_modules/ciga/analysis/tgraph_community_analysis.html#tgraph_community_leiden"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ciga.tgraph_community_leiden" title="Link to this definition">¶</a></dt>
<dd><p>Execute community detection on a temporal graph using the Leiden algorithm.</p>
<p>This function leverages the <cite>sequential_analysis</cite> function to perform community detection
on each snapshot of the provided <cite>TGraph</cite> object. It utilizes the Leiden algorithm to
identify communities within each graph snapshot based on specified parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tgraph</strong> (<a class="reference internal" href="graph.html#ciga.TGraph" title="ciga.TGraph"><em>TGraph</em></a>) – The temporal graph instance to analyze.</p></li>
<li><p><strong>accumulate</strong> (<em>bool</em><em>, </em><em>optional</em>) – If set to <cite>True</cite>, each graph snapshot will accumulate changes from all previous snapshots.
Defaults to <cite>True</cite>.</p></li>
<li><p><strong>start</strong> (<em>optional</em>) – The starting time step for the analysis. Only time steps &gt;= <cite>start</cite> will be considered.
Defaults to <cite>None</cite>, which includes all time steps from the beginning.</p></li>
<li><p><strong>end</strong> (<em>optional</em>) – The ending time step for the analysis. Only time steps &lt;= <cite>end</cite> will be considered.
Defaults to <cite>None</cite>, which includes all time steps until the end.</p></li>
<li><p><strong>weights</strong> (<em>str</em><em>, </em><em>optional</em>) – The edge attribute used as weights for the community detection algorithm.
Defaults to <cite>‘weight’</cite>.</p></li>
<li><p><strong>objective_function</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>The objective function to optimize during community detection.
Common options include:</p>
<blockquote>
<div><ul>
<li><p><cite>’CPM’</cite>: Constant Potts Model</p></li>
<li><p><cite>’Modularity’</cite></p></li>
<li><p><cite>’Negative Log-likelihood’</cite></p></li>
</ul>
</div></blockquote>
<p>Defaults to <cite>‘CPM’</cite>.</p>
</p></li>
<li><p><strong>resolution</strong> (<em>float</em><em>, </em><em>optional</em>) – The resolution parameter influencing the size of detected communities.
Higher values lead to smaller communities. Defaults to <cite>1.0</cite>.</p></li>
<li><p><strong>beta</strong> (<em>float</em><em>, </em><em>optional</em>) – The resolution limit parameter balancing partition quality and computational efficiency.
Defaults to <cite>0.01</cite>.</p></li>
<li><p><strong>initial_membership</strong> (<em>list</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – A list specifying initial community memberships for each vertex.
If <cite>None</cite>, the algorithm starts with a random partition. Defaults to <cite>None</cite>.</p></li>
<li><p><strong>n_iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of iterations the Leiden algorithm should perform.
More iterations can refine community structures but increase computation time.
Defaults to <cite>2</cite>.</p></li>
<li><p><strong>node_weights</strong> (<em>list</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – A list of weights for each node, influencing community detection.
If <cite>None</cite>, all nodes are treated equally. Useful for emphasizing certain nodes.
Defaults to <cite>None</cite>.</p></li>
<li><p><strong>**kwds</strong> – Additional keyword arguments to customize the Leiden algorithm further.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A DataFrame containing community assignments for each vertex at each time step.
Includes positional information and the corresponding community index.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If invalid parameters are provided or required data is missing.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="graph-properties">
<h2>Graph Properties<a class="headerlink" href="#graph-properties" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="ciga.graph_transitivity_undirected">
<span class="sig-prename descclassname"><span class="pre">ciga.</span></span><span class="sig-name descname"><span class="pre">graph_transitivity_undirected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nan'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="reference internal" href="_modules/ciga/analysis/graph_properties.html#graph_transitivity_undirected"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ciga.graph_transitivity_undirected" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the transitivity (clustering coefficient) of an undirected graph.</p>
<p>Transitivity measures the likelihood that the adjacent vertices of a vertex are connected.
It is also known as the clustering coefficient.</p>
<p>If the input graph is directed, it will be converted to an undirected graph by collapsing
multiple edges and treating them as single undirected edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>graph</strong> (<em>igraph.Graph</em>) – The input graph for which transitivity is to be calculated.</p></li>
<li><p><strong>mode</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>Determines the behavior when the graph does not contain any triplets (triads).
- <cite>“zero”</cite> or <cite>TRANSITIVITY_ZERO</cite>:</p>
<blockquote>
<div><p>Returns <cite>0.0</cite> if the graph does not have any triplets.</p>
</div></blockquote>
<ul>
<li><dl class="simple">
<dt><cite>”nan”</cite> or <cite>TRANSITIVITY_NAN</cite>:</dt><dd><p>Returns <cite>NaN</cite> (Not a Number) if the graph does not have any triplets.</p>
</dd>
</dl>
</li>
</ul>
<p>Defaults to <cite>‘nan’</cite>.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transitivity of the graph. Returns either a floating-point number representing
the transitivity or <cite>NaN</cite> based on the specified mode when no triplets are present.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ciga.tgraph_transitivity_undirected">
<span class="sig-prename descclassname"><span class="pre">ciga.</span></span><span class="sig-name descname"><span class="pre">tgraph_transitivity_undirected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tgraph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="graph.html#ciga.TGraph" title="ciga.ciga.TGraph"><span class="pre">TGraph</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accumulate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nan'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">DataFrame</span></span></span><a class="reference internal" href="_modules/ciga/analysis/tgraph_properties.html#tgraph_transitivity_undirected"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#ciga.tgraph_transitivity_undirected" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the transitivity (clustering coefficient) of an undirected time-varying graph.</p>
<p>This function uses the <cite>sequential_analysis</cite> function to compute the transitivity of the
graph at each time step. Transitivity measures the likelihood that the adjacent vertices
of a vertex are connected.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tgraph</strong> (<a class="reference internal" href="graph.html#ciga.TGraph" title="ciga.TGraph"><em>TGraph</em></a>) – The time-varying graph instance to analyze.</p></li>
<li><p><strong>accumulate</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, each graph snapshot will include changes from all previous snapshots.
Defaults to <cite>True</cite>.</p></li>
<li><p><strong>start</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>, </em><em>optional</em>) – The starting time step for the transitivity calculation.
Only time steps &gt;= <cite>start</cite> will be considered.
Defaults to <cite>None</cite>.</p></li>
<li><p><strong>end</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em><em>, </em><em>optional</em>) – The ending time step for the transitivity calculation.
Only time steps &lt;= <cite>end</cite> will be considered.
Defaults to <cite>None</cite>.</p></li>
<li><p><strong>mode</strong> (<em>str</em><em>, </em><em>optional</em>) – The mode for calculating transitivity. Defaults to <cite>‘nan’</cite>.
Other modes can be specified as supported by the underlying analysis function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A DataFrame containing the transitivity of the graph for each specified time step.
Includes positional information and the transitivity value.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pd.DataFrame</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Warning</strong> – If the provided graphs are directed, a warning is raised indicating that they will be converted to undirected.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="dependencies">
<h2>Dependencies<a class="headerlink" href="#dependencies" title="Link to this heading">¶</a></h2>
<p><strong>Python</strong>: <a class="reference external" href="https://igraph.org/python/">igraph</a>, <a class="reference external" href="https://pandas.pydata.org/">pandas</a>, <a class="reference external" href="https://numpy.org/">numpy</a> library</p>
</section>
<section id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h2>
<p>Centrality analysis</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">ciga</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cg</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">viztracer</span><span class="w"> </span><span class="kn">import</span> <span class="n">VizTracer</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;../../m_data.csv&#39;</span><span class="p">)</span>

<span class="c1"># custom weight function</span>
<span class="c1"># input: interaction (str)</span>
<span class="c1"># output: weight (float)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">weight_func</span><span class="p">(</span><span class="n">interaction</span><span class="p">):</span>
    <span class="c1"># return sid.polarity_scores(interaction)[&#39;neg&#39;]</span>
    <span class="k">return</span> <span class="mi">1</span>

<span class="c1"># tracer = VizTracer()</span>
<span class="c1"># tracer.start()</span>

<span class="c1"># load data</span>
<span class="n">interactions</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">prepare_data</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;Season&#39;</span><span class="p">,</span> <span class="s1">&#39;Episode&#39;</span><span class="p">,</span> <span class="s1">&#39;Scene&#39;</span><span class="p">,</span> <span class="s1">&#39;Line&#39;</span><span class="p">),</span>
                                <span class="n">source</span><span class="o">=</span><span class="s1">&#39;Speaker&#39;</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="s1">&#39;Listener&#39;</span><span class="p">,</span> <span class="n">interaction</span><span class="o">=</span><span class="s1">&#39;Words&#39;</span><span class="p">)</span>
<span class="n">sub_interactions</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="n">interactions</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="n">weights</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">calculate_weights</span><span class="p">(</span><span class="n">sub_interactions</span><span class="p">,</span> <span class="n">weight_func</span><span class="o">=</span><span class="n">weight_func</span><span class="p">)</span>

<span class="n">agg_weights</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">agg_weights</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;Season&#39;</span><span class="p">,</span> <span class="s1">&#39;Episode&#39;</span><span class="p">,</span> <span class="s1">&#39;Scene&#39;</span><span class="p">,</span> <span class="s1">&#39;Line&#39;</span><span class="p">),</span> <span class="n">agg_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="c1"># create network</span>
<span class="n">tg</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">TGraph</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">agg_weights</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Season&#39;</span><span class="p">,</span> <span class="s1">&#39;Episode&#39;</span><span class="p">,</span> <span class="s1">&#39;Scene&#39;</span><span class="p">,</span> <span class="s1">&#39;Line&#39;</span><span class="p">),</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># centrality analysis</span>
<span class="c1"># res = cg.tgraph_eigenvector_centrality(tg, weighted=True, scale=True, return_eigenvalue=False)</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">tgraph_degree</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># res = cg.tgraph_betweenness(tg, weighted=True, normalized=True)</span>
<span class="c1"># res = cg.tgraph_closeness(tg, weighted=True, normalized=True)</span>
<span class="n">res</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>

<span class="c1"># tracer.stop()</span>
<span class="c1"># tracer.save()</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">get_graph</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">cg</span><span class="o">.</span><span class="n">iplot</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vcount</span><span class="p">(),</span> <span class="n">g</span><span class="o">.</span><span class="n">ecount</span><span class="p">())</span>

<span class="n">res</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;centrality_res.csv&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Community detection</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">ciga</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cg</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">viztracer</span><span class="w"> </span><span class="kn">import</span> <span class="n">VizTracer</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;../../m_data.csv&#39;</span><span class="p">)</span>


<span class="c1"># custom weight function</span>
<span class="c1"># input: interaction (str)</span>
<span class="c1"># output: weight (float)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">weight_func</span><span class="p">(</span><span class="n">interaction</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span>

<span class="c1"># tracer = VizTracer()</span>
<span class="c1"># tracer.start()</span>

<span class="c1"># load data with weight</span>
<span class="c1"># weights = cg.prepare_data(df, (&#39;Season&#39;, &#39;Episode&#39;, &#39;Scene&#39;, &#39;Line&#39;),</span>
<span class="c1">#                           source=&#39;Speaker&#39;, target=&#39;Listener&#39;, interaction=&#39;Words&#39;, weight=&#39;weight&#39;)</span>

<span class="c1"># load data without weight</span>
<span class="n">interactions</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">prepare_data</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;Season&#39;</span><span class="p">,</span> <span class="s1">&#39;Episode&#39;</span><span class="p">,</span> <span class="s1">&#39;Scene&#39;</span><span class="p">,</span> <span class="s1">&#39;Line&#39;</span><span class="p">),</span>
                                <span class="n">source</span><span class="o">=</span><span class="s1">&#39;Speaker&#39;</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="s1">&#39;Listener&#39;</span><span class="p">,</span> <span class="n">interaction</span><span class="o">=</span><span class="s1">&#39;Words&#39;</span><span class="p">)</span>
<span class="n">sub_interactions</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="n">interactions</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1"># calculate weight</span>
<span class="n">weights</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">calculate_weights</span><span class="p">(</span><span class="n">sub_interactions</span><span class="p">,</span> <span class="n">weight_func</span><span class="o">=</span><span class="n">weight_func</span><span class="p">)</span>

<span class="c1"># adjust grain size</span>
<span class="n">agg_weights</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">agg_weights</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;Season&#39;</span><span class="p">,</span> <span class="s1">&#39;Episode&#39;</span><span class="p">,</span> <span class="s1">&#39;Scene&#39;</span><span class="p">,</span> <span class="s1">&#39;Line&#39;</span><span class="p">),</span> <span class="n">agg_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="c1"># create network</span>
<span class="n">tg</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">TGraph</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">agg_weights</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Season&#39;</span><span class="p">,</span> <span class="s1">&#39;Episode&#39;</span><span class="p">,</span> <span class="s1">&#39;Scene&#39;</span><span class="p">,</span> <span class="s1">&#39;Line&#39;</span><span class="p">),</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">communities</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">tgraph_community_leiden</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">weights</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="n">objective_function</span><span class="o">=</span><span class="s1">&#39;CPM&#39;</span><span class="p">)</span>

<span class="c1"># tracer.stop()</span>
<span class="c1"># tracer.save()</span>

<span class="n">communities</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;community_test.csv&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Non-accumulated centrality analysis</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">ciga</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cg</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">viztracer</span><span class="w"> </span><span class="kn">import</span> <span class="n">VizTracer</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;../../m_data.csv&#39;</span><span class="p">)</span>

<span class="c1"># custom weight function</span>
<span class="c1"># input: interaction (str)</span>
<span class="c1"># output: weight (float)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">weight_func</span><span class="p">(</span><span class="n">interaction</span><span class="p">):</span>
    <span class="c1"># return sid.polarity_scores(interaction)[&#39;neg&#39;]</span>
    <span class="k">return</span> <span class="mi">1</span>

<span class="c1"># tracer = VizTracer()</span>
<span class="c1"># tracer.start()</span>

<span class="c1"># load data</span>
<span class="n">interactions</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">prepare_data</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;Season&#39;</span><span class="p">,</span> <span class="s1">&#39;Episode&#39;</span><span class="p">,</span> <span class="s1">&#39;Scene&#39;</span><span class="p">,</span> <span class="s1">&#39;Line&#39;</span><span class="p">),</span>
                                <span class="n">source</span><span class="o">=</span><span class="s1">&#39;Speaker&#39;</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="s1">&#39;Listener&#39;</span><span class="p">,</span> <span class="n">interaction</span><span class="o">=</span><span class="s1">&#39;Words&#39;</span><span class="p">)</span>
<span class="n">sub_interactions</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">segment</span><span class="p">(</span><span class="n">interactions</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="n">weights</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">calculate_weights</span><span class="p">(</span><span class="n">sub_interactions</span><span class="p">,</span> <span class="n">weight_func</span><span class="o">=</span><span class="n">weight_func</span><span class="p">)</span>

<span class="n">agg_weights</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">agg_weights</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;Season&#39;</span><span class="p">,</span> <span class="s1">&#39;Episode&#39;</span><span class="p">,</span> <span class="s1">&#39;Scene&#39;</span><span class="p">,</span> <span class="s1">&#39;Line&#39;</span><span class="p">),</span> <span class="n">agg_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="c1"># create network</span>
<span class="n">tg</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">TGraph</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">agg_weights</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Season&#39;</span><span class="p">,</span> <span class="s1">&#39;Episode&#39;</span><span class="p">,</span> <span class="s1">&#39;Scene&#39;</span><span class="p">,</span> <span class="s1">&#39;Line&#39;</span><span class="p">),</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># centrality analysis</span>
<span class="c1"># res = cg.tgraph_eigenvector_centrality(tg, weighted=True, scale=True, return_eigenvalue=False)</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">tgraph_degree</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="n">accumulate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># res = cg.tgraph_betweenness(tg, weighted=True, normalized=True)</span>
<span class="c1"># res = cg.tgraph_closeness(tg, weighted=True, normalized=True)</span>
<span class="n">res</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>

<span class="c1"># tracer.stop()</span>
<span class="c1"># tracer.save()</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">get_graph</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">cg</span><span class="o">.</span><span class="n">iplot</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vcount</span><span class="p">(),</span> <span class="n">g</span><span class="o">.</span><span class="n">ecount</span><span class="p">())</span>

<span class="n">res</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;non_acc_centrality_res.csv&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">CIGA</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="data.html">Data (<code class="xref py py-mod docutils literal notranslate"><span class="pre">ciga</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph.html">Graph (<code class="xref py py-mod docutils literal notranslate"><span class="pre">ciga</span></code>)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Analysis (<code class="xref py py-mod docutils literal notranslate"><span class="pre">ciga</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#centrality-analysis">Centrality Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="#community-detection">Community Detection</a></li>
<li class="toctree-l2"><a class="reference internal" href="#graph-properties">Graph Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="#usage">Usage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Visualization (<code class="xref py py-mod docutils literal notranslate"><span class="pre">ciga</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="Legal.html">Legal Information</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="graph.html" title="previous chapter">Graph (<code class="xref py py-mod docutils literal notranslate"><span class="pre">ciga</span></code>)</a></li>
      <li>Next: <a href="visualization.html" title="next chapter">Visualization (<code class="xref py py-mod docutils literal notranslate"><span class="pre">ciga</span></code>)</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Shu Hu.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/analysis.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>
<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ciga.utils.data_utils &#8212; CIGA 2025 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=27fed22d" />
    <script src="../../../_static/documentation_options.js?v=cb975c41"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for ciga.utils.data_utils</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>


<div class="viewcode-block" id="prepare_data">
<a class="viewcode-back" href="../../../data.html#ciga.prepare_data">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">prepare_data</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">position</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
        <span class="n">source</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;source&#39;</span><span class="p">,</span>
        <span class="n">target</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;target&#39;</span><span class="p">,</span>
        <span class="n">interaction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;interaction&#39;</span><span class="p">,</span>
        <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prepare the input data for analysis by validating, sorting, and renaming columns.</span>

<span class="sd">    Args:</span>
<span class="sd">        data (pd.DataFrame): The input dataframe containing interaction data.</span>
<span class="sd">        position (Tuple[str, ...]): Column names used for positional indexing.</span>
<span class="sd">        source (str, optional): Name of the source column. Defaults to &#39;source&#39;.</span>
<span class="sd">        target (str, optional): Name of the target column. Defaults to &#39;target&#39;.</span>
<span class="sd">        interaction (str, optional): Name of the interaction column. Defaults to &#39;interaction&#39;.</span>
<span class="sd">        weight (Optional[str], optional): Name of the weight column, if any. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: The processed dataframe ready for analysis.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If required columns are missing or position columns are not numeric.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check required columns</span>
    <span class="n">required_columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">weight</span><span class="p">:</span>
        <span class="n">required_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">col</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">required_columns</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;Missing required columns.</span><span class="se">\n</span><span class="s2">Expected: </span><span class="si">{</span><span class="n">required_columns</span><span class="si">}</span><span class="se">\n</span><span class="s2">Found: </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># examine data</span>
    <span class="n">_check_numeric_position</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>

    <span class="c1"># sort by position</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">position</span><span class="p">))</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># use multi-index for quick interval selection</span>
    <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">position</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># rename columns</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">source</span><span class="p">:</span> <span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="s1">&#39;target&#39;</span><span class="p">})</span>
    <span class="k">if</span> <span class="n">interaction</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">interaction</span><span class="p">:</span> <span class="s1">&#39;interaction&#39;</span><span class="p">})</span>

    <span class="c1"># Process &#39;source&#39;, &#39;target&#39;, &#39;observer&#39; columns to ensure lists</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_process_column</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">])</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_process_column</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">weight</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">weight</span><span class="p">:</span> <span class="s1">&#39;weight&#39;</span><span class="p">})</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">_flatten_weights</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="segment">
<a class="viewcode-back" href="../../../data.html#ciga.segment">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">segment</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract a subset of interactions based on a specified interval.</span>

<span class="sd">    Args:</span>
<span class="sd">        data (pd.DataFrame): The dataframe containing interaction data.</span>
<span class="sd">        start (tuple, optional): The starting position of the interval. Defaults to None.</span>
<span class="sd">        end (tuple, optional): The ending position of the interval. Defaults to None.</span>
<span class="sd">        position (tuple, optional): Column names used for positional indexing. Required if multi-indexing is needed. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A dataframe containing interactions within the specified interval.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If multi-level time steps are required but position columns are not provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">position</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Position columns required for multi-level time step.&quot;</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">position</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">IndexSlice</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">],</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">interval</span></div>



<div class="viewcode-block" id="calculate_weights">
<a class="viewcode-back" href="../../../data.html#ciga.calculate_weights">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_weights</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">weight_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate weights for each interaction based on a provided weight function.</span>

<span class="sd">    Args:</span>
<span class="sd">        data (pd.DataFrame): The dataframe containing interaction data.</span>
<span class="sd">        weight_func (Callable, optional): A function that takes an interaction entry and returns a numerical weight. Defaults to lambda x: len(x).</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: The dataframe with an added &#39;weight&#39; column and flattened weights.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;interaction&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">weight_func</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">_flatten_weights</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_flatten_weights</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Expand the dataframe so that each source-target pair has its own row.</span>

<span class="sd">    This is useful when the &#39;source&#39; and &#39;target&#39; columns contain lists,</span>
<span class="sd">    ensuring that each interaction is represented as a single row.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): The dataframe with potential list-like &#39;source&#39; and &#39;target&#39; columns.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: The exploded dataframe with individual source-target pairs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="s1">&#39;source&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="s1">&#39;target&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="agg_weights">
<a class="viewcode-back" href="../../../data.html#ciga.agg_weights">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">agg_weights</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">agg_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Aggregate weights by grouping interactions based on positional columns and source-target pairs.</span>

<span class="sd">    Args:</span>
<span class="sd">        data (pd.DataFrame): The dataframe containing interaction data with weights.</span>
<span class="sd">        position (Tuple[str, ...]): Column names used for positional indexing (excluding the line identifier).</span>
<span class="sd">        agg_func (Callable, optional): The aggregation function to apply to the weights. Defaults to sum.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: The aggregated dataframe with summed weights for each group.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the &#39;weight&#39; column is missing from the dataframe.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># group by position and source, target, observer</span>
    <span class="c1"># raise error if &#39;weight&#39; column is not found</span>
    <span class="k">if</span> <span class="s1">&#39;weight&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No &#39;weight&#39; column found. You should run calculate_weights() first.&quot;</span><span class="p">)</span>
    <span class="n">grouped</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;target&#39;</span><span class="p">])[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">agg_func</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">grouped</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">_process_column</span><span class="p">(</span><span class="n">series</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process a dataframe column to ensure each cell contains a list of unique, stripped string items.</span>

<span class="sd">    Args:</span>
<span class="sd">        series (pd.Series): The column to process.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.Series: The processed column with each cell as a list of unique, stripped strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">clean_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">items</span> <span class="o">=</span> <span class="n">cell</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;[]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">series</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">clean_cell</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_check_numeric_position</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate that all position columns contain numeric data types.</span>

<span class="sd">    Args:</span>
<span class="sd">        data (pd.DataFrame): The dataframe containing position columns.</span>
<span class="sd">        position (Tuple[str, ...]): Column names used for positional indexing.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If any position column does not have a numeric data type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check required columns</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">position</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Position column &#39;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&#39; must be numeric.&quot;</span><span class="p">)</span>

<span class="c1"># Infer listener LLM</span>

<span class="k">def</span><span class="w"> </span><span class="nf">generate_prompt</span><span class="p">(</span><span class="n">scene_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a formatted prompt for the language model to identify listeners in dialogue lines.</span>

<span class="sd">    Args:</span>
<span class="sd">        scene_data (Dict[str, Any]): A dictionary containing scene descriptions and dialogue lines.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: A formatted prompt string to be sent to the language model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prompt</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Scene Description: </span><span class="si">{</span><span class="n">scene_data</span><span class="p">[</span><span class="s1">&#39;Scene_Description&#39;</span><span class="p">]</span><span class="si">}</span>

<span class="s2">    Dialogue Lines:</span>
<span class="s2">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">scene_data</span><span class="p">[</span><span class="s1">&#39;Lines&#39;</span><span class="p">]:</span>
        <span class="n">prompt</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Line </span><span class="si">{</span><span class="n">line</span><span class="p">[</span><span class="s1">&#39;Line_ID&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">line</span><span class="p">[</span><span class="s1">&#39;Speaker&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">: </span><span class="se">\&quot;</span><span class="si">{</span><span class="n">line</span><span class="p">[</span><span class="s1">&#39;Line&#39;</span><span class="p">]</span><span class="si">}</span><span class="se">\&quot;\n</span><span class="s2">&quot;</span>

    <span class="n">prompt</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    For each line, identify the listeners from the characters present. Provide the results in JSON format only, following this exact structure:</span>

<span class="s2">    {</span>
<span class="s2">      &quot;listeners&quot;: {</span>
<span class="s2">        &quot;1&quot;: [&quot;Listener1&quot;, &quot;Listener2&quot;],</span>
<span class="s2">        &quot;2&quot;: [&quot;Listener3&quot;],</span>
<span class="s2">        ...</span>
<span class="s2">      }</span>
<span class="s2">    }</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="c1"># print(&quot;&gt;&gt; prompt:\n&quot;, prompt)</span>

    <span class="k">return</span> <span class="n">prompt</span>


<span class="k">def</span><span class="w"> </span><span class="nf">infer_scene_listeners</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">prompt</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;openai&quot;</span><span class="p">,</span> <span class="n">max_tokens</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use a language model to infer listeners for each dialogue line in a scene.</span>

<span class="sd">    Args:</span>
<span class="sd">        client: The API client for interacting with the language model.</span>
<span class="sd">        model_name (str): The name of the language model to use.</span>
<span class="sd">        prompt (str): The prompt string generated for the language model.</span>
<span class="sd">        mode (str, optional): The service provider (&quot;openai&quot; or &quot;anthropic&quot;). Defaults to &quot;openai&quot;.</span>
<span class="sd">        max_tokens (int, optional): The maximum number of tokens for the response. Defaults to 200.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dict[str, List[str]]: A dictionary mapping line IDs to lists of listeners.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Ensures the response is valid JSON and adheres to the expected structure.</span>
<span class="sd">        - Implements error handling for JSON decoding and other exceptions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">listeners_json</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">listeners_data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;openai&quot;</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">openai</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">chat</span><span class="o">.</span><span class="n">completions</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
                <span class="c1"># model=&quot;gpt-4o-mini&quot;,</span>
                <span class="n">model</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span>
                <span class="n">messages</span><span class="o">=</span><span class="p">[</span>
                    <span class="p">{</span><span class="s2">&quot;role&quot;</span><span class="p">:</span> <span class="s2">&quot;system&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;content&quot;</span><span class="p">:</span> <span class="s2">&quot;You are an assistant that identifies listeners for each line in a conversation. Respond only with JSON following the specified format.&quot;</span><span class="p">},</span>
                    <span class="p">{</span><span class="s2">&quot;role&quot;</span><span class="p">:</span> <span class="s2">&quot;user&quot;</span><span class="p">,</span> <span class="s2">&quot;content&quot;</span><span class="p">:</span> <span class="n">prompt</span><span class="p">}</span>
                <span class="p">],</span>
                <span class="n">max_tokens</span><span class="o">=</span><span class="n">max_tokens</span><span class="p">,</span>
                <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">temperature</span><span class="o">=</span><span class="mf">0.3</span>
            <span class="p">)</span>
            <span class="c1"># print(&quot;&gt;&gt; response:\n&quot;, response)</span>
            <span class="c1"># print(&quot;&gt;&gt; response.choices[0].message.content:\n&quot;, response.choices[0].message.content)</span>
            <span class="n">listeners_json</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">choices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">content</span>

            <span class="c1"># Validate that the response is proper JSON and matches the expected structure</span>
            <span class="n">listeners_data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">listeners_json</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;anthropic&quot;</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">anthropic</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">messages</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
                <span class="n">model</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span>
                <span class="n">messages</span><span class="o">=</span><span class="p">[</span>
                    <span class="p">{</span><span class="s2">&quot;role&quot;</span><span class="p">:</span> <span class="s2">&quot;user&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;content&quot;</span><span class="p">:</span> <span class="s2">&quot;You are an assistant that identifies listeners for each line in a conversation. Respond only with JSON following the specified format.</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">prompt</span><span class="p">}</span>
                <span class="p">],</span>
                <span class="n">max_tokens</span><span class="o">=</span><span class="n">max_tokens</span>
            <span class="p">)</span>
            <span class="c1"># print(&quot;&gt;&gt; response:\n&quot;, response)</span>
            <span class="c1"># print(&quot;&gt;&gt; response.choices[0].message.content:\n&quot;, response.content[0].text)</span>
            <span class="n">listeners_data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;listeners&quot;</span> <span class="ow">in</span> <span class="n">listeners_data</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">listeners_data</span><span class="p">[</span><span class="s2">&quot;listeners&quot;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">listeners_data</span><span class="p">[</span><span class="s2">&quot;listeners&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;JSON response does not match the expected format.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{}</span>
    <span class="k">except</span> <span class="n">json</span><span class="o">.</span><span class="n">JSONDecodeError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Failed to decode JSON. Response was:&quot;</span><span class="p">,</span> <span class="n">listeners_json</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error inferring listeners for scene: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{}</span>

<div class="viewcode-block" id="infer_listeners">
<a class="viewcode-back" href="../../../data.html#ciga.infer_listeners">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">infer_listeners</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
                    <span class="n">position</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                    <span class="n">speaker</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;speaker&#39;</span><span class="p">,</span>
                    <span class="n">dialogue</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;dialogue&#39;</span><span class="p">,</span>
                    <span class="n">action</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">scene_description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">client</span><span class="p">:</span> <span class="n">Optional</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;openai&quot;</span><span class="p">,</span>
                    <span class="n">max_tokens</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
                    <span class="n">gap</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Infer listeners for each dialogue line across different scenes using a language model.</span>

<span class="sd">    Args:</span>
<span class="sd">        data (pd.DataFrame): The dataframe containing interaction data.</span>
<span class="sd">        position (Tuple[str, ...]): Column names used for positional indexing.</span>
<span class="sd">        speaker (str, optional): Name of the speaker column. Defaults to &#39;speaker&#39;.</span>
<span class="sd">        dialogue (str, optional): Name of the dialogue column. Defaults to &#39;dialogue&#39;.</span>
<span class="sd">        action (Optional[str], optional): Name of the action notes column. Defaults to None.</span>
<span class="sd">        scene_description (Optional[str], optional): Name of the scene description column. Defaults to None.</span>
<span class="sd">        client (Optional, optional): The API client for interacting with the language model. Defaults to None.</span>
<span class="sd">        model (Optional[str], optional): The name of the language model to use. Defaults to None.</span>
<span class="sd">        mode (str, optional): The service provider (&quot;openai&quot; or &quot;anthropic&quot;). Defaults to &quot;openai&quot;.</span>
<span class="sd">        max_tokens (int, optional): The maximum number of tokens for the response. Defaults to 200.</span>
<span class="sd">        gap (float, optional): Delay between API requests to prevent rate limiting. Defaults to 1.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: The dataframe with an added &#39;listener&#39; column containing inferred listeners.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If required columns are missing or position columns are not numeric.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">required_columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">speaker</span><span class="p">,</span> <span class="n">dialogue</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">col</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">required_columns</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;Missing required columns.</span><span class="se">\n</span><span class="s2">Expected: </span><span class="si">{</span><span class="n">required_columns</span><span class="si">}</span><span class="se">\n</span><span class="s2">Found: </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">_check_numeric_position</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">position</span><span class="p">))</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">speaker</span><span class="p">:</span> <span class="s1">&#39;speaker&#39;</span><span class="p">})</span>
    <span class="k">if</span> <span class="n">dialogue</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">dialogue</span><span class="p">:</span> <span class="s1">&#39;dialogue&#39;</span><span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;dialogue&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">action</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">action</span><span class="p">:</span> <span class="s1">&#39;action&#39;</span><span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;action&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">scene_description</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">scene_description</span><span class="p">:</span> <span class="s1">&#39;scene_description&#39;</span><span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;scene_description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Process &#39;source&#39;, &#39;target&#39;, &#39;observer&#39; columns to ensure lists</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;speaker&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_process_column</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;speaker&#39;</span><span class="p">])</span>

    <span class="c1"># print(df)</span>
    <span class="c1"># check data type of speaker column elements</span>
    <span class="c1"># print(df.iloc[0][&#39;speaker&#39;])</span>
    <span class="c1"># print(type(df.iloc[0][&#39;speaker&#39;]))</span>

    <span class="c1"># return</span>

    <span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">position</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">scene_json</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;listener&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># use tqdm for progress bar</span>
    <span class="c1"># for scene_number, group in grouped</span>
    <span class="k">for</span> <span class="n">scene_number</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">grouped</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Processing scenes&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;scene&#39;</span><span class="p">):</span>
        <span class="c1"># print(&quot;&gt;&gt; scene_number:&quot;, scene_number)</span>
        <span class="c1"># print(&quot;&gt;&gt; group:\n&quot;, group)</span>
        <span class="n">scene_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Scene_Description&quot;</span><span class="p">:</span> <span class="n">group</span><span class="p">[</span><span class="s1">&#39;scene_description&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s2">&quot;Lines&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="s2">&quot;Line_ID&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">position</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]),</span>
                    <span class="s2">&quot;Speaker&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;speaker&#39;</span><span class="p">]),</span>
                    <span class="s2">&quot;Line&quot;</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;dialogue&#39;</span><span class="p">],</span>
                    <span class="s2">&quot;Action_Notes&quot;</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;action&#39;</span><span class="p">]</span>
                <span class="p">}</span>
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="p">}</span>
        <span class="c1"># print(&quot;&gt;&gt; scene_data before inference:\n&quot;, json.dumps(scene_data, indent=4))</span>

        <span class="c1"># Infer listeners for the entire scene</span>
        <span class="n">prompt</span> <span class="o">=</span> <span class="n">generate_prompt</span><span class="p">(</span><span class="n">scene_data</span><span class="p">)</span>
        <span class="n">listeners</span> <span class="o">=</span> <span class="n">infer_scene_listeners</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">prompt</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">max_tokens</span><span class="o">=</span><span class="n">max_tokens</span><span class="p">)</span>

        <span class="c1"># Assign listeners to each line</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">scene_data</span><span class="p">[</span><span class="s2">&quot;Lines&quot;</span><span class="p">]:</span>
            <span class="n">line_id</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="s2">&quot;Line_ID&quot;</span><span class="p">]</span>
            <span class="n">line</span><span class="p">[</span><span class="s2">&quot;Listeners&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">listeners</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">line_id</span><span class="p">),</span> <span class="p">[])</span>
            <span class="c1"># for row with column position[-1] == line_id, assign listeners</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">position</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">scene_number</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
                   <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">position</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="n">line_id</span><span class="p">),</span> <span class="s1">&#39;listener&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="s2">&quot;Listeners&quot;</span><span class="p">])</span>

        <span class="c1"># print(&quot;&gt;&gt; scene_data after inference:\n&quot;, json.dumps(scene_data, indent=4))</span>
        <span class="n">scene_json</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scene_data</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">gap</span><span class="p">)</span>  <span class="c1"># Adjust delay as needed</span>
    <span class="k">return</span> <span class="n">df</span></div>


</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">CIGA</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../data.html">Data (<code class="xref py py-mod docutils literal notranslate"><span class="pre">ciga</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../graph.html">Graph (<code class="xref py py-mod docutils literal notranslate"><span class="pre">ciga</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analysis.html">Analysis (<code class="xref py py-mod docutils literal notranslate"><span class="pre">ciga</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../visualization.html">Visualization (<code class="xref py py-mod docutils literal notranslate"><span class="pre">ciga</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Legal.html">Legal Information</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Shu Hu.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>